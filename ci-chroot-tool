#!/usr/bin/python3

from typing import Optional
import subprocess
import argparse
import logging
import shlex
import sys
import os


def sh(*cmd):
    try:
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError as e:
        raise Fail(f"Command '{' '.join(shlex.quote(c) for c in cmd)}' exited with status {e.returncode}")


class Fail(RuntimeError):
    """
    Exception raised when the program should exit with an error but without a
    backtrace
    """
    pass


class Command:
    # Command name (as used in command line)
    # Defaults to the lowercased class name
    NAME: Optional[str] = None

    # Command description (as used in command line help)
    # Defaults to the strip()ped class docstring.
    DESC: Optional[str] = None

    def __init__(self, args):
        self.args = args
        self.setup_logging()

    def setup_logging(self):
        # Setup logging
        FORMAT = "%(asctime)-15s %(levelname)s %(name)s %(message)s"
        log_handler = logging.StreamHandler(sys.stderr)
        log_handler.setFormatter(logging.Formatter(FORMAT))
        if self.args.debug:
            log_handler.setLevel(logging.DEBUG)
        elif self.args.verbose:
            log_handler.setLevel(logging.INFO)
        else:
            log_handler.setLevel(logging.WARN)
        root_logger = logging.getLogger()
        root_logger.addHandler(log_handler)
        root_logger.setLevel(logging.DEBUG)

    @classmethod
    def get_name(cls):
        if cls.NAME is not None:
            return cls.NAME
        return cls.__name__.lower()

    @classmethod
    def make_subparser(cls, subparsers):
        desc = cls.DESC
        if desc is None:
            desc = cls.__doc__.strip()

        parser = subparsers.add_parser(cls.get_name(), help=desc)
        parser.set_defaults(handler=cls)
        parser.add_argument("-v", "--verbose", action="store_true", help="verbose output")
        parser.add_argument("--debug", action="store_true", help="verbose output")
        return parser


# usage() {
#
#     cat <<EOF
# Usage: $0 <command> [options]
# where <command> is one of:
#
#  bootstrap_image <name> <OS name> <size> [<fs type>]
#   bootstrap a minimal OS on a filesystem in a raw file image
#    <name> name of the image file
#    <OS name> name of the distro (centos7, centos8, fedora32, fedora34
#     at the moment)
#    <size> size of the image in MB (as understood by dd, e.g. "1K" gives
#     1G image size)
#    <fs type> filesystem type (default ext4)
#
#  bootstrap_dir <name> <OS name>
#   bootstrap a minimal OS on a local directory
#    <name> name of the directory
#    <OS name> name of the distro (centos7, centos8, fedora32, fedora34
#     at the moment)
#
#  prepare_image <base> <dest> [-r <size>] [-p]
#   copy a minimal readonly image to a writable file for starting a
#   container instance, optionally resizing it and embedding in a
#   partitioned disk image
#    <base> base raw image file (untouched)
#    <dest> destination image file, if a lot of RAM is available can be
#     on a tmpfs filesystem
#    -r <size> to resize the destination image, with <size> as
#     understood by fsadm/resize2fs, e.g. 640M, 5G (default no resize)
#    -p embed destination image in a single-partition disk image
#     (required by older systemd)
#
# EOF
#     exit 1
# }
#
#
#
# dnf_or_yum() {
#     if type dnf 2>/dev/null; then
#         export DY=dnf
#     elif type yum 2>/dev/null; then
#         export DY=yum
#     else
#         echo "yum or dnf not found"
#         exit 1
#     fi
# }
#
#
# bootstrap_centos7() {
#     # bootstrap with local yum
#     cat > chroot-initial.repo << EOF
# [chroot-base]
# name=Linux \$releasever - \$basearch
# baseurl=http://mirror.centos.org/centos/7/os/\$basearch
# enabled=1
# gpgcheck=0
# EOF
#     $DY -q -c chroot-initial.repo -y --disablerepo=* \
#         --enablerepo=chroot-base --disableplugin=* \
#         --installroot=$PWD --releasever=7 \
#         install bash vim-minimal yum rootfiles
#
#     rm -f chroot-initial.repo
# }
#
# bootstrap_centos8() {
#     # bootstrap with local yum
#     cat > chroot-initial.repo << EOF
# [chroot-base]
# name=Linux \$releasever - \$basearch
# baseurl=http://mirror.centos.org/centos-8/8/BaseOS/\$basearch/os
# enabled=1
# gpgcheck=0
# EOF
#     $DY -q -c chroot-initial.repo -y --disablerepo=* \
#         --enablerepo=chroot-base --disableplugin=* \
#         --installroot=$PWD --releasever=8 \
#         install bash vim-minimal dnf rootfiles
#
#     rm -f chroot-initial.repo
# }
#
# bootstrap_fedora32() {
#     # bootstrap with local yum
#     cat > chroot-initial.repo << EOF
# [chroot-base]
# name=Linux \$releasever - \$basearch
# baseurl=http://download.fedoraproject.org/pub/fedora/linux/releases/32/Everything/\$basearch/os/
# enabled=1
# gpgcheck=0
# EOF
#     $DY -q -c chroot-initial.repo -y --disablerepo=* \
#         --enablerepo=chroot-base --disableplugin=* \
#         --installroot=$PWD --releasever=32 \
#         install bash vim-minimal dnf rootfiles
#
#     rm -f chroot-initial.repo
# }
#
# bootstrap_fedora34() {
#     # bootstrap with local yum
#     cat > chroot-initial.repo << EOF
# [chroot-base]
# name=Linux \$releasever - \$basearch
# baseurl=http://download.fedoraproject.org/pub/fedora/linux/releases/34/Everything/\$basearch/os/
# enabled=1
# gpgcheck=0
# EOF
#     $DY -q -c chroot-initial.repo -y --disablerepo=* \
#         --enablerepo=chroot-base --disableplugin=* \
#         --installroot=$PWD --releasever=34 \
#         install bash vim-minimal dnf rootfiles
#
#     rm -f chroot-initial.repo
# }
#
# # bootstrap a minimal OS on a local directory
# # $1 name of the directory
# # $2 OS name (centos7, centos8, fedora32, fedora34)
# bootstrap_dir() {
#     RDIR=$1
#     OS=$2
#     if [ -d "$RDIR" ]; then
#         echo "directory $RDIR exists, please remove it first!"
#         exit 1
#     fi
#
#     mkdir $RDIR
#     cd $RDIR
#
#     dnf_or_yum
#     bootstrap_$OS
#     # for travis build
#     mkdir -p root/src
#     cd ..
# }
#
#
# bootstrap_image() {
#     RFILE=$1
#     OS=$2
#     SIZE=$3
#     FSTYPE=${4:-ext4}
#     RDIR=mnt
#     INDIR=$PWD
#     if [ -f "$RFILE" ]; then
#         echo "file $RFILE exists, please remove it first!"
#         exit 1
#     fi
#
#     # cleanup code: trap { set +e; cd $INDIR; umount $RDIR; rmdir $RDIR; rm -f $RFILE } ...
#     # create fs
#     dd if=/dev/zero of=$RFILE bs=1M count=$SIZE conv=sparse status=noxfer
#     if [[ $FSTYPE == "ext4" ]]; then
#         mkfs.ext4 -q $RFILE
#     else
#         mkfs -t $FSTYPE $RFILE
#     fi
#
#     # mount fs
#     mkdir $RDIR
#     mount -o loop $RFILE $RDIR
#     cd $RDIR
#
#     dnf_or_yum
#     bootstrap_$OS
#     # for travis build
#     mkdir -p root/src
#     cd ..
#
#     # unmount fs
#     umount $RDIR
#     rmdir $RDIR
#     echo "raw image $RFILE ready"
# }
#
#
# prepare_image() {
#     RFILE=$1
#     RDISK=$2
#     SIZE=
#     PART=
#     shift; shift
#     while [ "$#" -gt 0 ]; do
#         case $1 in
#             -r)
#                 SIZE=$2
#                 shift
#                 ;;
#             -p)
#                 PART=Y
#                 ;;
#         esac
#         shift
#     done
#
#     if [ -f "$RDISK" ]; then
#         echo "file $RDISK exists, please remove it first!"
#         exit 1
#     fi
#
#     if [ -n "$SIZE" ]; then # resize requested
#         # resize a temporary image
#         cp --sparse=always $RFILE $RDISK
#         e2fsck -f $RDISK
#         resize2fs $RDISK $SIZE # try with fsadm resize? xfs must be mounted
#         if [ -n "$PART" ]; then # prepare for partitioning
#             mv $RDISK $RDISK.tmp
#             RFILE=$RDISK.tmp
#         fi
#     else
#         if [ ! -n "$PART" ]; then
#             cp --sparse=always $RFILE $RDISK
#         fi
#
#     fi
#
#
#     if [ -n "$PART" ]; then
#         # create MBR
#         dd if=/dev/zero of=$RDISK count=1 bs=1M status=noxfer
#         # append raw partition to MBR
#         cat $RFILE >> $RDISK
#         # partition the disk
#         parted -s $RDISK 'mktable msdos'
#         parted -s $RDISK 'mkpart primary ext2 1049kB -1s'
#         parted -s $RDISK 'set 1 boot on'
#         rm -f $RDISK.tmp
#     fi
# }
#

class LaunchBuild(Command):
    """
    clone a git repository and launch a container instance in the
    requested OS chroot executing a build in the cloned source tree
    according to .travis-build.sh script (or <buildscript> if set)
    """
    NAME = "launch_build"

    @classmethod
    def make_subparser(cls, subparsers):
        parser = super().make_subparser(subparsers)
        parser.add_argument("--shell", action="store_true",
                            help="run a shell instead of the build script")
        parser.add_argument("repo",
                            help="git url of the repository to clone")
        parser.add_argument("image",
                            help="image file or base directory to use as chroot")
        parser.add_argument("tag",
                            help="tag to be passed to the build script")
        parser.add_argument("branch",
                            help="branch to be used")
        parser.add_argument("buildscript", nargs="?", default=".travis-build.sh",
                            help="build script that must accept <tag> as argument")
        return parser

    def run(self):
        sh("git", "clone", self.args.repo, "--branch", self.args.branch)
        dirname = os.path.basename(self.args.repo)
        if dirname.endswith(".git"):
            dirname = dirname[:-4]

        if not os.path.isdir(dirname):
            raise Fail(f"git clone of {self.args.repo!r} did not create {dirname!r}")

        # if [[ -n "$BUILDSCRIPT" ]]; then
        #     [[ -e "$BUILDSCRIPT" ]] || { echo "build script $BUILDSCRIPT does not exist"; exit 1; }
        #     buildscript=./.travis-build.sh
        # else
        #     buildscript=$(mktemp -p .)
        #     cp $BUILDSCRIPT $buildscript
        # fi

        cmd = [
           f'--bind-ro={os.path.abspath(dirname)}:/root/src',
        ]
        if not self.args.shell:
            cmd += [
               "sh", "-c",
               f"cd /root/src/{shlex.quote(dirname)};"
               f"sh {shlex.quote(self.args.buildscript)} {shlex.quote(self.args.tag)}"
            ]

        if os.path.isfile(self.args.image):
            # filesystem image
            cmd = ["systemd-nspawn", "-i", self.args.image, "--ephemeral"] + cmd
            sh(*cmd)
        elif os.path.isdir(self.args.image):
            # local dir
            cmd = ["systemd-nspawn", "-D", self.args.image, "--volatile=overlay"] + cmd
        else:
            raise Fail(f"image {self.args.image!r} does not exist")
        # TODO: save the build result somehow


# case $command in
#     bootstrap_image)
#         bootstrap_image "$@"
#         ;;
#     bootstrap_dir)
#         bootstrap_dir "$@"
#         ;;
#     prepare_image)
#         prepare_image "$@"
#         ;;
#     launch_build)
#         launch_build "$@"
#         ;;
#     *)
#         usage
# esac

def main():
    parser = argparse.ArgumentParser(description="CI tool")
    subparsers = parser.add_subparsers(help="sub-command help", dest="command", required=True)

    LaunchBuild.make_subparser(subparsers)

    args = parser.parse_args()
    handler = args.handler(args)
    res = handler.run()
    if res is not None:
        sys.exit(res)


if __name__ == "__main__":
    try:
        main()
    except Fail as e:
        print(e, file=sys.stderr)
        sys.exit(1)
